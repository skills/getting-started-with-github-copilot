import time
import datetime
import json
import requests
import numpy as np
import asyncio
import random
from binance.client import Client
from binance.exceptions import BinanceAPIException
from telegram import Bot
from telegram.error import TelegramError

# ================= Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Binance Ùˆ Telegram ================= #
BINANCE_API_KEY = "amYzUD1gKVWw9br7BrT64RQG6qQIZpLSXLMkI6OfgLRTUYsE9dXfXDSSpCAv7tm4"
BINANCE_API_SECRET = "e3PyPrxamf90LoUbzK1m1aUc8QdfPZP1ihdosTvOOoFJT8kvUdJdXXPkPPJeBzJ3"
TELEGRAM_BOT_TOKEN = "7870773249:AAFthY0F38f1MFdkOSO1Xqf3_bNAjgy41ws"
TELEGRAM_CHAT_ID = "@abdulaziz_btc_bot"

# ================= Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ ================= #
INTERVALS = [
    (Client.KLINE_INTERVAL_30MINUTE, "30 Ø¯Ù‚ÙŠÙ‚Ø©"),
    (Client.KLINE_INTERVAL_1HOUR,   "1 Ø³Ø§Ø¹Ø©"),
    (Client.KLINE_INTERVAL_1DAY,    "1 ÙŠÙˆÙ…"),
]
RISK_PERCENT = 1  # Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø© Ù…Ù† Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ Ù„ÙƒÙ„ ØµÙÙ‚Ø©
TAKE_PROFIT_RATIOS = [1, 2, 3]  # Ù†Ø³Ø¨ Ø¬Ù†ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­
STOP_LOSS_RATIO = 1  # Ù†Ø³Ø¨Ø© ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©
MIN_24H_VOLUME = 50000000  # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ø­Ø¬Ù… Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„ÙŠÙˆÙ…ÙŠ
MIN_TRADE_SIZE = 10  # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±
TRAILING_STOP_PERCENT = 0.5  # Ù…Ø³Ø§ÙØ© Ø§Ù„ØªÙˆÙ‚Ù Ø§Ù„Ù…ØªØ­Ø±Ùƒ Ø¨Ù†Ø³Ø¨Ø© 0.5%

# ================= Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª ================= #
RSI_PERIOD = 14
MACD_FAST = 12
MACD_SLOW = 26
MACD_SIGNAL = 9
MFI_PERIOD = 14  # ÙØªØ±Ø© Ù…Ø¤Ø´Ø± ØªØ¯ÙÙ‚ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©

# ØªÙ‡ÙŠØ¦Ø© Ø¹Ù…ÙŠÙ„ Binance Ùˆ Telegram
client = Client(BINANCE_API_KEY, BINANCE_API_SECRET)
telegram_bot = Bot(token=TELEGRAM_BOT_TOKEN)

# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª - Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ«Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
SYMBOLS = []
symbols_last_updated = 0
SYMBOLS_UPDATE_INTERVAL = 3600  # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© ÙƒÙ„ Ø³Ø§Ø¹Ø©
SYMBOL_IMAGE_CACHE_FILE = "symbol_images.json"  # Ù…Ù„Ù Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„ØµÙˆØ±

# Ù‚Ø§Ù…ÙˆØ³ Ù„Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ø´Ù‡ÙŠØ±Ø© ÙÙŠ CoinGecko
COINGECKO_IDS = {
    "BTCUSDT": "bitcoin",
    "ETHUSDT": "ethereum",
    "ETCUSDT": "ethereum-classic",
    "BNBUSDT": "binancecoin",
    "SOLUSDT": "solana",
    "XRPUSDT": "ripple",
    "ADAUSDT": "cardano",
    "DOGEUSDT": "dogecoin",
    "DOTUSDT": "polkadot",
    "AVAXUSDT": "avalanche",
    "LINKUSDT": "chainlink",
    "MATICUSDT": "matic-network",
    "LTCUSDT": "litecoin",
    "ATOMUSDT": "cosmos",
    "UNIUSDT": "uniswap",
    "ALGOUSDT": "algorand",
    "XLMUSDT": "stellar",
    "VETUSDT": "vechain",
    "ICPUSDT": "internet-computer",
    "FILUSDT": "filecoin",
    "TRXUSDT": "tron",
    "AXSUSDT": "axie-infinity",
    "SANDUSDT": "the-sandbox",
    "MANAUSDT": "decentraland",
    "NEARUSDT": "near",
    "FTMUSDT": "fantom",
    "GRTUSDT": "the-graph",
    "AAVEUSDT": "aave",
}

# Ù…Ù„Ù Ø³Ø¬Ù„ Ø§Ù„ØµÙÙ‚Ø§Øª
TRADE_LOG_FILE = "trades_log.json"

# ========== ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù† ÙˆØ§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± ========== #
def load_symbol_images_cache():
    """ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ± Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª"""
    try:
        with open(SYMBOL_IMAGE_CACHE_FILE, 'r') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

def save_symbol_images_cache(cache):
    """Ø­ÙØ¸ Ø§Ù„ØµÙˆØ± ÙÙŠ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª"""
    try:
        with open(SYMBOL_IMAGE_CACHE_FILE, 'w') as f:
            json.dump(cache, f, indent=4)
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª: {str(e)}")

# ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„ØµÙˆØ±
symbol_images = load_symbol_images_cache()

def initialize_trade_log():
    """ØªÙ‡ÙŠØ¦Ø© Ù…Ù„Ù Ø³Ø¬Ù„ Ø§Ù„ØµÙÙ‚Ø§Øª"""
    try:
        with open(TRADE_LOG_FILE, 'r') as f:
            pass
    except FileNotFoundError:
        with open(TRADE_LOG_FILE, 'w') as f:
            json.dump([], f)

def log_trade(trade_info):
    """ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙÙ‚Ø© ÙÙŠ Ù…Ù„Ù Ø§Ù„Ø³Ø¬Ù„"""
    try:
        with open(TRADE_LOG_FILE, 'r+') as f:
            trades = json.load(f)
            trades.append(trade_info)
            f.seek(0)
            json.dump(trades, f, indent=4)
    except Exception as e:
        print(f"ÙØ´Ù„ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙÙ‚Ø©: {str(e)}")

def safe_api_request(url, params=None, max_retries=3, timeout=15):
    """ØªÙ†ÙÙŠØ° Ø·Ù„Ø¨Ø§Øª API Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù† Ù…Ø¹ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©"""
    for attempt in range(max_retries):
        try:
            response = requests.get(url, params=params, timeout=timeout)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 429:  # ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­
                retry_after = e.response.headers.get('Retry-After')
                if retry_after:
                    wait_time = float(retry_after) + random.uniform(1, 3)
                else:
                    wait_time = min(30, (3 ** attempt) + random.uniform(2, 5))
                print(f"ØªÙ… ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ {wait_time:.1f} Ø«ÙˆØ§Ù†ÙŠ...")
                time.sleep(wait_time)
            elif e.response.status_code in [404, 403]:
                print(f"Ø®Ø·Ø£ ØºÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¥ØµÙ„Ø§Ø­: {e.response.status_code}")
                return None
            else:
                print(f"Ø®Ø·Ø£ HTTP: {e.response.status_code} - {e.response.text}")
                time.sleep(3)
        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout) as e:
            wait_time = min(30, (3 ** attempt) + random.uniform(2, 5))
            print(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„: {str(e)}. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ {wait_time:.1f} Ø«ÙˆØ§Ù†ÙŠ...")
            time.sleep(wait_time)
        except Exception as e:
            print(f"Ø®Ø·Ø£ Ø¹Ø§Ù… ÙÙŠ Ø§Ù„Ø·Ù„Ø¨: {str(e)}")
            time.sleep(5)
    print(f"âŒ ÙØ´Ù„ Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø¹Ø¯ {max_retries} Ù…Ø­Ø§ÙˆÙ„Ø§Øª")
    return None

def get_symbol_image(symbol):
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ø§Ù„Ø¹Ù…Ù„Ø© Ù…Ù† CoinGecko Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†"""
    if symbol in symbol_images:
        return symbol_images[symbol]
    
    coin_id = COINGECKO_IDS.get(symbol, symbol.replace("USDT", "").lower())
    url = f"https://api.coingecko.com/api/v3/coins/{coin_id}"
    
    try:
        data = safe_api_request(url)
        if data and "image" in data and "large" in data["image"]:
            image_url = data["image"]["large"]
            symbol_images[symbol] = image_url
            save_symbol_images_cache(symbol_images)
            return image_url
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© {symbol}: {str(e)}")
    
    return "https://cryptologos.cc/logos/default.png"

def send_telegram_message_via_api(message):
    """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Telegram Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… API Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†"""
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": message,
        "parse_mode": "Markdown"
    }
    try:
        response = requests.post(url, json=payload, timeout=20)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¹Ø¨Ø± API: {str(e)}")
        return None

def update_symbols_list():
    """ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ù…Ù† Binance Futures Ù…Ø¹ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""
    global SYMBOLS, symbols_last_updated
    
    try:
        exchange_info = client.futures_exchange_info()
        symbols_data = exchange_info['symbols']
        
        # ØªØµÙÙŠØ© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„ØªÙŠ ØªÙ†ØªÙ‡ÙŠ Ø¨Ù€ USDT ÙˆÙ„Ù‡Ø§ Ø­Ø¬Ù… ØªØ¯Ø§ÙˆÙ„ ÙƒØ§ÙÙ
        usdt_pairs = [
            s['symbol'] for s in symbols_data 
            if s['quoteAsset'] == 'USDT' and 
               s['status'] == 'TRADING' and 
               s['contractType'] == 'PERPETUAL'
        ]
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø­Ø¬Ø§Ù… Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ù„Ø¢Ø®Ø± 24 Ø³Ø§Ø¹Ø©
        tickers = client.futures_ticker()
        symbol_volumes = []
        
        for symbol in usdt_pairs:
            for t in tickers:
                if t['symbol'] == symbol:
                    volume = float(t['quoteVolume'])
                    if volume > MIN_24H_VOLUME:
                        symbol_volumes.append((symbol, volume))
                    break
        
        symbol_volumes.sort(key=lambda x: x[1], reverse=True)
        
        # ØªØµÙÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        valid_symbols = []
        for symbol, volume in symbol_volumes[:100]:  # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 100 Ø¹Ù…Ù„Ø© Ù„Ù„ÙØ­Øµ
            try:
                # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø³Ø¹Ø± Ø§Ù„Ø¹Ù…Ù„Ø©
                ticker = client.futures_symbol_ticker(symbol=symbol)
                price = float(ticker['price'])
                
                # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª ØªØ§Ø±ÙŠØ®ÙŠØ©
                prices, volumes, _, _ = get_historical_data(symbol, Client.KLINE_INTERVAL_1HOUR)
                
                # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                if price > 0 and len(prices) > 10 and all(p > 0 for p in prices[-10:]):
                    valid_symbols.append(symbol)
                else:
                    print(f"â›” ØªØ®Ø·ÙŠ {symbol}: Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø© (Ø§Ù„Ø³Ø¹Ø±: {price}, Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: {len(prices)})")
                    
            except BinanceAPIException as e:
                if e.code == -1121:  # Ø±Ù…Ø² Ø®Ø·Ø£ Ø§Ù„Ø¹Ù…Ù„Ø© ØºÙŠØ± Ø§Ù„ØµØ§Ù„Ø­Ø©
                    print(f"â›” ØªØ®Ø·ÙŠ {symbol}: Ø¹Ù…Ù„Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©")
                else:
                    print(f"â›” ØªØ®Ø·ÙŠ {symbol}: Ø®Ø·Ø£ API ({e.code})")
            except Exception as e:
                print(f"â›” ØªØ®Ø·ÙŠ {symbol}: Ø®Ø·Ø£ Ø¹Ø§Ù… ({str(e)})")
        
        # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 50 Ø¹Ù…Ù„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªØµÙÙŠØ© Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©
        SYMBOLS = valid_symbols[:50]
        
        if SYMBOLS:
            symbols_last_updated = time.time()
            print(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª: {len(SYMBOLS)} Ø¹Ù…Ù„Ø©")
            
            message = (
                "ğŸ”„ *ØªÙ… ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©*\n"
                f"ğŸ“Š **Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù…Ù„Ø§Øª:** {len(SYMBOLS)}\n"
                "âš–ï¸ **Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰:** Ø£Ø¹Ù„Ù‰ 50 Ø¹Ù…Ù„Ø© Ø¨Ø­Ø¬Ù… Ø§Ù„ØªØ¯Ø§ÙˆÙ„"
            )
            send_telegram_message_via_api(message)
        else:
            print("âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù…Ù„Ø§Øª ØªÙ„Ø¨ÙŠ Ø§Ù„Ù…Ø¹Ø§ÙŠÙŠØ±")
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª: {str(e)}")

# ========== ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ ========== #
def get_atr(symbol, interval, period=14):
    """Ø­Ø³Ø§Ø¨ Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø¯Ù‰ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø§Ù„Ù…ØªÙˆØ³Ø· (ATR) Ù…Ø¹ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""
    try:
        supported_intervals = [i[0] for i in INTERVALS]
        if interval not in supported_intervals:
            print(f"Ø§Ù„ÙØ§ØµÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ [{interval}] ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… Ù„Ø­Ø³Ø§Ø¨ ATR Ù„Ù€ [{symbol}]")
            return 0
        
        klines = client.futures_klines(symbol=symbol, interval=interval, limit=period*2)
        if len(klines) < period:
            return 0

        tr_values = []
        for i in range(1, len(klines)):
            high = float(klines[i][2])
            low = float(klines[i][3])
            prev_close = float(klines[i-1][4])
            tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
            tr_values.append(tr)
        
        atr = sum(tr_values[-period:]) / period
        return atr
    except BinanceAPIException as e:
        print(f"Ø®Ø·Ø£ API ÙÙŠ Ø­Ø³Ø§Ø¨ ATR Ù„Ù€ [{symbol}] Ø¨ÙØ§ØµÙ„ [{interval}]: {e.status_code} - {e.message}")
        return 0
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ ATR Ù„Ù€ [{symbol}] Ø¨ÙØ§ØµÙ„ [{interval}]: {str(e)}")
        return 0

def get_historical_data(symbol, interval):
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ© Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†"""
    try:
        supported_intervals = [i[0] for i in INTERVALS]
        if interval not in supported_intervals:
            print(f"Ø§Ù„ÙØ§ØµÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ [{interval}] ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… Ù„Ù€ [{symbol}]")
            return [], [], [], []  # Ø¥Ø±Ø¬Ø§Ø¹ Ø£Ø±Ø¨Ø¹ Ù‚ÙˆØ§Ø¦Ù…: Ø§Ù„Ø£Ø³Ø¹Ø§Ø±ØŒ Ø§Ù„Ø£Ø­Ø¬Ø§Ù…ØŒ Ø§Ù„Ø£Ø¹Ù„Ù‰ØŒ Ø§Ù„Ø£Ø¯Ù†Ù‰
        
        klines = client.futures_klines(symbol=symbol, interval=interval, limit=100)
        opens = [float(kline[1]) for kline in klines]
        highs = [float(kline[2]) for kline in klines]
        lows = [float(kline[3]) for kline in klines]
        closes = [float(kline[4]) for kline in klines]
        volumes = [float(kline[5]) for kline in klines]
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬ÙˆØ¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        if len(closes) < 10 or any(price <= 0 for price in closes[-10:]):
            print(f"â›” Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ù„Ù€ [{symbol}] Ø¨ÙØ§ØµÙ„ [{interval}]")
            return [], [], [], []
            
        return closes, volumes, highs, lows
    except BinanceAPIException as e:
        print(f"Ø®Ø·Ø£ API ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù€ [{symbol}] Ø¨ÙØ§ØµÙ„ [{interval}]: {e.status_code} - {e.message}")
        return [], [], [], []
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù€ [{symbol}] Ø¨ÙØ§ØµÙ„ [{interval}]: {str(e)}")
        return [], [], [], []

def calculate_ema(prices, period):
    """Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…ØªØ­Ø±Ùƒ Ø§Ù„Ø£Ø³ÙŠ (EMA) Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†"""
    if len(prices) < period:
        return []
    try:
        ema = [sum(prices[:period]) / period]
        k = 2 / (period + 1)
        for price in prices[period:]:
            ema.append(price * k + ema[-1] * (1 - k))
        return ema
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ EMA: {str(e)}")
        return []

def calculate_rsi(prices, period=14):
    """Ø­Ø³Ø§Ø¨ Ù…Ø¤Ø´Ø± Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ù†Ø³Ø¨ÙŠØ© (RSI) Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†"""
    if len(prices) < period + 1:
        return None
    try:
        deltas = np.diff(prices)
        gains = [max(d, 0) for d in deltas]
        losses = [max(-d, 0) for d in deltas]
        
        avg_gain = sum(gains[:period]) / period
        avg_loss = sum(losses[:period]) / period or 0.001
        
        for i in range(period, len(gains)):
            avg_gain = (avg_gain * (period - 1) + gains[i]) / period
            avg_loss = (avg_loss * (period - 1) + losses[i]) / period
        
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ RSI: {str(e)}")
        return None

def calculate_mfi(highs, lows, closes, volumes, period=14):
    """Ø­Ø³Ø§Ø¨ Ù…Ø¤Ø´Ø± ØªØ¯ÙÙ‚ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© (MFI)"""
    if len(closes) < period:
        return None
    
    try:
        # Ø­Ø³Ø§Ø¨ Typical Price
        typical_prices = [(high + low + close) / 3 for high, low, close in zip(highs, lows, closes)]
        
        # Ø­Ø³Ø§Ø¨ Money Flow
        money_flows = [tp * vol for tp, vol in zip(typical_prices, volumes)]
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ø¥ÙŠØ¬Ø§Ø¨ÙŠ ÙˆØ§Ù„Ø³Ù„Ø¨ÙŠ
        positive_flows = []
        negative_flows = []
        
        for i in range(1, len(typical_prices)):
            if typical_prices[i] > typical_prices[i-1]:
                positive_flows.append(money_flows[i])
                negative_flows.append(0)
            elif typical_prices[i] < typical_prices[i-1]:
                negative_flows.append(money_flows[i])
                positive_flows.append(0)
            else:
                positive_flows.append(0)
                negative_flows.append(0)
        
        # Ø­Ø³Ø§Ø¨ Ù†Ø³Ø¨ Ø§Ù„ØªØ¯ÙÙ‚
        mfi_values = []
        for i in range(period, len(positive_flows)+1):
            sum_positive = sum(positive_flows[i-period:i])
            sum_negative = sum(negative_flows[i-period:i])
            
            if sum_negative == 0:  # ØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰ ØµÙØ±
                mfi = 100
            else:
                money_ratio = sum_positive / sum_negative
                mfi = 100 - (100 / (1 + money_ratio))
            
            mfi_values.append(mfi)
        
        return mfi_values[-1] if mfi_values else None
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ MFI: {str(e)}")
        return None

def analyze_technical_indicators(prices, volumes, highs, lows):
    """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ© Ù…Ø¹ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©"""
    try:
        if len(prices) < max(MACD_SLOW + 1, RSI_PERIOD + 1):
            return {
                "MACD": None, 
                "RSI": None, 
                "Volume Spike": None,
                "MFI": None,
                "Liquidity Sentiment": None
            }

        # Ø­Ø³Ø§Ø¨ MACD
        ema_fast = calculate_ema(prices, MACD_FAST)[-50:] or []
        ema_slow = calculate_ema(prices, MACD_SLOW)[-50:] or []
        if not ema_fast or not ema_slow:
            return {
                "MACD": None, 
                "RSI": None, 
                "Volume Spike": None,
                "MFI": None,
                "Liquidity Sentiment": None
            }

        min_length = min(len(ema_fast), len(ema_slow))
        macd_line = [ema_fast[i] - ema_slow[i] for i in range(-min_length, 0)]
        macd_signal = calculate_ema(macd_line, MACD_SIGNAL) or []
        if not macd_signal:
            return {
                "MACD": None, 
                "RSI": None, 
                "Volume Spike": None,
                "MFI": None,
                "Liquidity Sentiment": None
            }

        macd = macd_line[-1] - macd_signal[-1] if macd_line and macd_signal else None

        # Ø­Ø³Ø§Ø¨ RSI
        rsi = calculate_rsi(prices[-100:], RSI_PERIOD) if len(prices) >= RSI_PERIOD + 1 else None

        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­Ø¬Ù…
        avg_volume = np.mean(volumes[-14:]) if len(volumes) >= 14 else 0
        last_volume = volumes[-1] if volumes else 0
        volume_spike = last_volume > avg_volume * 1.5
        
        # Ø­Ø³Ø§Ø¨ Ù…Ø¤Ø´Ø± ØªØ¯ÙÙ‚ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© (MFI)
        mfi = calculate_mfi(highs, lows, prices, volumes, period=MFI_PERIOD)
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©
        liquidity_sentiment = "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
        if mfi is not None:
            if mfi > 70:
                liquidity_sentiment = "Ø³Ù„Ø¨ÙŠØ© (ØªØ´Ø¨Ø¹ Ø´Ø±Ø§Ø¦ÙŠ)"
            elif mfi < 30:
                liquidity_sentiment = "Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ© (ØªØ´Ø¨Ø¹ Ø¨ÙŠØ¹ÙŠ)"
            elif mfi > 50:
                liquidity_sentiment = "Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©"
            else:
                liquidity_sentiment = "Ø³Ù„Ø¨ÙŠØ©"

        return {
            "MACD": macd, 
            "RSI": rsi, 
            "Volume Spike": volume_spike,
            "MFI": mfi,
            "Liquidity Sentiment": liquidity_sentiment
        }
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ©: {str(e)}")
        return {
            "MACD": None, 
            "RSI": None, 
            "Volume Spike": None,
            "MFI": None,
            "Liquidity Sentiment": None
        }

# ========== ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ ÙˆØ§Ù„ØªÙ†ÙÙŠØ° ========== #
def get_daily_trend(symbol):
    """ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù…Ø¹ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""
    try:
        klines = client.futures_klines(
            symbol=symbol,
            interval=Client.KLINE_INTERVAL_1DAY,
            limit=3
        )
        if len(klines) < 3:
            return "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
        
        prices = [float(k[4]) for k in klines]
        ticker = client.futures_symbol_ticker(symbol=symbol)
        current_price = float(ticker['price']) if isinstance(ticker, dict) else float(ticker[0]['price'])
        
        sma = np.mean(prices)
        return "ØµØ¹ÙˆØ¯ÙŠ" if current_price > sma else "Ù‡Ø¨ÙˆØ·ÙŠ"
    except BinanceAPIException as e:
        print(f"Ø®Ø·Ø£ API ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù€ [{symbol}]: {e.status_code} - {e.message}")
        return "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù„Ù€ [{symbol}]: {str(e)}")
        return "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"

def get_available_balance():
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø­ Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†"""
    try:
        account_info = client.futures_account_balance()
        usdt_balance = next((item for item in account_info if item['asset'] == 'USDT'), None)
        if usdt_balance:
            return float(usdt_balance['availableBalance']), float(usdt_balance['balance'])
        return 0, 0
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±ØµÙŠØ¯: {str(e)}")
        return 0, 0

def calculate_position_size(symbol, entry_price, stop_loss, risk_percent=RISK_PERCENT):
    """Ø­Ø¬Ù… Ø§Ù„Ù…Ø±ÙƒØ² Ù…Ø¹ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±"""
    try:
        available_balance, _ = get_available_balance()
        if available_balance <= MIN_TRADE_SIZE:
            return 0
        
        # Ø­Ø³Ø§Ø¨ Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø© Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±
        risk_amount = available_balance * (risk_percent / 100)
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø© Ù„ÙƒÙ„ Ø¹Ù‚Ø¯ (Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±)
        risk_per_contract = abs(entry_price - stop_loss)
        if risk_per_contract == 0:
            print(f"â›” Ø®Ø·Ø± Ø§Ù„ØµÙÙ‚Ø© ØµÙØ± Ù„Ù€ [{symbol}] - Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„Ù…Ø±ÙƒØ²")
            return 0
        
        # Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù‚ÙˆØ¯ (Ø¨Ø¯ÙˆÙ† ØªÙ‚Ø±ÙŠØ¨)
        contracts = risk_amount / risk_per_contract
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¹Ù‚Ø¯
        symbol_info = client.futures_exchange_info()
        symbol_data = next((s for s in symbol_info['symbols'] if s['symbol'] == symbol), None)
        if not symbol_data:
            return 0
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø­Ø¬Ù… Ø§Ù„Ø®Ø·ÙˆØ©
        step_size = 0.001  # Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        for filt in symbol_data['filters']:
            if filt['filterType'] == 'LOT_SIZE':
                step_size = float(filt['stepSize'])
                break
        
        # Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„Ù…Ø±ÙƒØ² Ù…Ø¹ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„ØµØ­ÙŠØ­
        position_size = max(round(contracts - (contracts % step_size), 8), step_size)
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø©
        position_value = position_size * entry_price
        if position_value < MIN_TRADE_SIZE:
            return 0
            
        # ØªØ³Ø¬ÙŠÙ„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨
        print(f"[{symbol}] Ø­Ø¬Ù… Ø§Ù„Ù…Ø±ÙƒØ²: {position_size:.4f} | Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø±ÙƒØ²: {position_value:.2f} USD | Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©: {risk_amount:.2f} USD")
            
        return position_size
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„Ù…Ø±ÙƒØ²: {str(e)}")
        return 0

def execute_trade(symbol, signal, position_size, entry_price, stop_loss, tp_levels):
    """ØªÙ†ÙÙŠØ° Ø£Ù…Ø± ØªØ¯Ø§ÙˆÙ„ Ù…Ø¹ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""
    if position_size <= 0:
        return False
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù‚ÙŠÙ… Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†ÙÙŠØ°
    if entry_price <= 0 or any(tp <= 0 for tp in tp_levels) or stop_loss <= 0:
        print(f"â›” Ù‚ÙŠÙ… ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ù„Ù€ [{symbol}] - Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªÙ†ÙÙŠØ° Ø§Ù„ØµÙÙ‚Ø©")
        return False
        
    try:
        side = 'BUY' if signal == 'BUY' else 'SELL'
        order = client.futures_create_order(
            symbol=symbol,
            side=side,
            type='MARKET',
            quantity=position_size,
            reduceOnly=False
        )
        set_stop_loss_and_take_profit(symbol, side, position_size, entry_price, stop_loss, tp_levels)
        return True
    except BinanceAPIException as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ ØªÙ†ÙÙŠØ° Ø§Ù„Ø£Ù…Ø±: {e.status_code} - {e.message}")
    except Exception as e:
        print(f"Ø®Ø·Ø£ Ø¹Ø§Ù… ÙÙŠ Ø§Ù„ØªÙ†ÙÙŠØ°: {str(e)}")
    return False

def set_stop_loss_and_take_profit(symbol, side, position_size, entry_price, stop_loss, tp_levels):
    """ÙˆØ¶Ø¹ Ø£ÙˆØ§Ù…Ø± Ø§Ù„ÙˆÙ‚Ù Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†"""
    try:
        # ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„Ù…ØªØ­Ø±Ùƒ
        callback_rate = TRAILING_STOP_PERCENT  # Ù†Ø³Ø¨Ø© Ø§Ù„ØªÙˆÙ‚Ù Ø§Ù„Ù…ØªØ­Ø±Ùƒ
        
        client.futures_create_order(
            symbol=symbol,
            side='SELL' if side == 'BUY' else 'BUY',
            type='TRAILING_STOP_MARKET',
            quantity=position_size,
            callbackRate=callback_rate,  # Ù†Ø³Ø¨Ø© Ø§Ù„ØªÙˆÙ‚Ù (0.5%)
            activationPrice=None,  # ÙŠØ¨Ø¯Ø£ Ø§Ù„ØªØªØ¨Ø¹ ÙÙˆØ± ÙˆØ¶Ø¹ Ø§Ù„Ø£Ù…Ø±
            reduceOnly=True
        )
        
        # Ø¬Ù†ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­
        tp_qty = position_size / len(tp_levels)
        for tp in tp_levels:
            client.futures_create_order(
                symbol=symbol,
                side='SELL' if side == 'BUY' else 'BUY',
                type='TAKE_PROFIT_MARKET',
                quantity=tp_qty,
                stopPrice=tp,
                closePosition=False
            )
        return True
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ ÙˆØ¶Ø¹ Ø£ÙˆØ§Ù…Ø± Ø§Ù„ÙˆÙ‚Ù: {str(e)}")
        return False

# ========== ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ========== #
async def async_send_telegram_alert(symbol, trade_signal, price, entry_price, tp_levels, stop_loss, trend, frame, indicators, position_size, executed=False):
    """Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¹Ø¨Ø± Telegram Ù…Ø¹ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©"""
    coin_name = symbol.replace("USDT", "")
    status = "âœ… ØªÙ… Ø§Ù„ØªÙ†ÙÙŠØ°" if executed else "âš ï¸ Ø¥Ø´Ø§Ø±Ø© ÙÙ‚Ø·"
    
    # Ø¥Ø¶Ø§ÙØ© ØªØ­Ø°ÙŠØ± Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ… ØºÙŠØ± ØµØ§Ù„Ø­Ø©
    warning_msg = ""
    if entry_price <= 0 or any(tp <= 0 for tp in tp_levels) or stop_loss <= 0:
        warning_msg = "\n\nğŸš¨ **ØªØ­Ø°ÙŠØ±: Ø¨Ø¹Ø¶ Ø§Ù„Ù‚ÙŠÙ… ØºÙŠØ± ØµØ§Ù„Ø­Ø©!**\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ ÙŠØ¯ÙˆÙŠÙ‹Ø§ Ù‚Ø¨Ù„ Ø§Ù„ØªØ¯Ø§ÙˆÙ„"
    
    # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙˆÙ‚Ù Ø§Ù„Ù…ØªØ­Ø±Ùƒ
    trailing_info = f"\nğŸ“‰ **ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„Ù…ØªØ­Ø±Ùƒ:** {TRAILING_STOP_PERCENT}%"
    
    # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠÙˆÙ„Ø©
    liquidity_info = (
        f"\nğŸ’§ **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©:** {indicators['Liquidity Sentiment']}"
        f"\nğŸ“Š **Ù…Ø¤Ø´Ø± MFI:** {indicators['MFI']:.2f}" if indicators['MFI'] is not None else ""
    )
    
    message = (
        f"ğŸš€ *Ø¥Ø´Ø§Ø±Ø© ØªØ¯Ø§ÙˆÙ„ Ø¬Ø¯ÙŠØ¯Ø©* ({frame}) - {status}\n"
        f"ğŸ”¸ **Ø§Ù„Ø¹Ù…Ù„Ø©:** {coin_name}/{symbol}\n"
        f"ğŸ”¸ **Ø§Ù„Ø¥Ø´Ø§Ø±Ø©:** {'ğŸŸ© Ø´Ø±Ø§Ø¡' if trade_signal == 'BUY' else 'ğŸŸ¥ Ø¨ÙŠØ¹'}\n"
        f"â–ªï¸ **Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ:** ${price:.4f}\n"
        f"ğŸ”¹ **Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„:** ${entry_price:.4f}\n"
        f"ğŸ“ˆ **Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø±Ø¨Ø­:**\n"
        f"    TP1: ${tp_levels[0]:.4f}\n"
        f"    TP2: ${tp_levels[1]:.4f}\n"
        f"    TP3: ${tp_levels[2]:.4f}\n"
        f"ğŸ“Š **Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙŠÙˆÙ…ÙŠ:** {trend}\n"
        f"ğŸ’¹ **Ø§Ø±ØªÙØ§Ø¹ ÙÙŠ Ø§Ù„Ø­Ø¬Ù…:** {'âœ… Ù†Ø¹Ù…' if indicators['Volume Spike'] else 'âŒ Ù„Ø§'}\n"
        f"ğŸ’° **Ø­Ø¬Ù… Ø§Ù„Ù…Ø±ÙƒØ²:** {position_size:.4f} {coin_name}"
        f"{trailing_info}"
        f"{liquidity_info}"
        f"{warning_msg}"
    )
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø©
    image_url = symbol_images.get(symbol, "https://cryptologos.cc/logos/default.png")
    
    try:
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø§Ù„Ù†Øµ
        await telegram_bot.send_photo(
            chat_id=TELEGRAM_CHAT_ID,
            photo=image_url,
            caption=message,
            parse_mode="Markdown"
        )
    except TelegramError as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©: {str(e)}")
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†ØµÙŠØ© ÙÙ‚Ø· ÙƒØ¨Ø¯ÙŠÙ„
        try:
            await telegram_bot.send_message(
                chat_id=TELEGRAM_CHAT_ID,
                text=message,
                parse_mode="Markdown"
            )
            print("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†ØµÙŠØ© Ø¨Ù†Ø¬Ø§Ø­")
        except TelegramError as e2:
            print(f"ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†ØµÙŠØ©: {str(e2)}")
    except Exception as e:
        print(f"Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: {str(e)}")

def send_telegram_alert(symbol, trade_signal, price, entry_price, tp_levels, stop_loss, trend, frame, indicators, position_size, executed=False):
    """Ø·Ø¨Ù‚Ø© ØªÙØ§Ù Ù„Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†"""
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(
            async_send_telegram_alert(
                symbol, trade_signal, price, entry_price,
                tp_levels, stop_loss, trend, frame,
                indicators, position_size, executed
            )
        )
        loop.close()
    except Exception as e:
        print(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…: {str(e)}")

# ========== Ø§Ù„Ø¥Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ========== #
def live_strategy_multi_timeframes():
    """Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„ÙØ±ÙŠÙ…Ø§Øª Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡"""
    global SYMBOLS, symbols_last_updated
    
    # ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø¥Ø°Ø§ Ø­Ø§Ù† ÙˆÙ‚Øª Ø§Ù„ØªØ­Ø¯ÙŠØ«
    if time.time() - symbols_last_updated > SYMBOLS_UPDATE_INTERVAL:
        update_symbols_list()
    
    available_balance, _ = get_available_balance()
    if available_balance < MIN_TRADE_SIZE:
        print(f"â›” Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ: {available_balance:.2f} USDT")
        return
    
    symbols_to_check = SYMBOLS[:min(50, len(SYMBOLS))]
    for symbol in symbols_to_check:
        try:
            daily_trend = get_daily_trend(symbol)
            
            for interval, label in INTERVALS:
                try:
                    prices, volumes, highs, lows = get_historical_data(symbol, interval)
                    if len(prices) < 40:
                        continue

                    indicators = analyze_technical_indicators(prices, volumes, highs, lows)
                    if indicators["MACD"] is None or indicators["RSI"] is None:
                        continue

                    current_price = float(client.futures_symbol_ticker(symbol=symbol)['price'])
                    
                    # ØªØ®Ø·ÙŠ Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø°Ø§Øª Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ØºÙŠØ± Ø§Ù„ØµØ§Ù„Ø­Ø©
                    if current_price <= 0:
                        print(f"â›” ØªØ®Ø·ÙŠ {symbol}: Ø³Ø¹Ø± ØºÙŠØ± ØµØ§Ù„Ø­ ({current_price})")
                        continue
                    
                    signal = None
                    
                    # Ø´Ø±ÙˆØ· Ø§Ù„Ø´Ø±Ø§Ø¡ ÙˆØ§Ù„Ø¨ÙŠØ¹
                    if indicators["MACD"] > 0 and indicators["RSI"] < 30:
                        signal = "BUY"
                    elif indicators["MACD"] < 0 and indicators["RSI"] > 70:
                        signal = "SELL"
                    
                    if signal:
                        # ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©
                        if signal == "BUY" and indicators["Liquidity Sentiment"] == "Ø³Ù„Ø¨ÙŠØ©":
                            print(f"â­ï¸ ØªØ®Ø·ÙŠ Ø¥Ø´Ø§Ø±Ø© Ø´Ø±Ø§Ø¡ Ù„Ù€ {symbol} Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ø§Ù„Ø³Ù„Ø¨ÙŠØ©")
                            continue
                            
                        if signal == "SELL" and indicators["Liquidity Sentiment"] == "Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©":
                            print(f"â­ï¸ ØªØ®Ø·ÙŠ Ø¥Ø´Ø§Ø±Ø© Ø¨ÙŠØ¹ Ù„Ù€ {symbol} Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ø§Ù„Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©")
                            continue
                        
                        atr = get_atr(symbol, interval) or (current_price * 0.01)
                        if signal == "BUY":
                            entry = current_price
                            tp_levels = [entry + (ratio * atr) for ratio in TAKE_PROFIT_RATIOS]
                            sl = entry - (STOP_LOSS_RATIO * atr)
                        else:  # SELL
                            entry = current_price
                            tp_levels = [entry - (ratio * atr) for ratio in TAKE_PROFIT_RATIOS]
                            sl = entry + (STOP_LOSS_RATIO * atr)
                        
                        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ø­Ø³ÙˆØ¨Ø©
                        if any(value <= 0 for value in [entry] + tp_levels + [sl]):
                            print(f"â›” Ù‚ÙŠÙ… ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ù„Ù€ [{symbol}]:")
                            print(f"   Ø§Ù„Ø¯Ø®ÙˆÙ„: {entry}, TP: {tp_levels}, SL: {sl}")
                            continue
                        
                        position_size = calculate_position_size(symbol, entry, sl)
                        if position_size > 0:
                            executed = execute_trade(symbol, signal, position_size, entry, sl, tp_levels)
                            send_telegram_alert(
                                symbol, signal, current_price, entry,
                                tp_levels, sl, daily_trend, label,
                                indicators, position_size, executed
                            )
                            # Ø¨Ø¹Ø¯ Ø£ÙˆÙ„ Ø¥Ø´Ø§Ø±Ø© ØµØ§Ù„Ø­Ø© Ù†Ø®Ø±Ø¬ Ù…Ù† Ø­Ù„Ù‚Ø© Ø§Ù„ÙØ±ÙŠÙ…Ø§Øª
                            break
                except Exception as e:
                    print(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø·Ø§Ø± Ø§Ù„Ø²Ù…Ù†ÙŠ [{interval}] Ù„Ù„Ø¹Ù…Ù„Ø© [{symbol}]: {str(e)}")
        except Exception as e:
            print(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ù…Ù„Ø© [{symbol}]: {str(e)}")
        
        time.sleep(1)  # Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÙŠÙ† ÙƒÙ„ Ø¹Ù…Ù„Ø© ÙˆØ£Ø®Ø±Ù‰

# ========== Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ========== #
if __name__ == "__main__":
    initialize_trade_log()
    update_symbols_list()
    
    available_balance, total_balance = get_available_balance()
    print(f"ğŸ’° Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø£ÙˆÙ„ÙŠ: ${available_balance:.2f} | ${total_balance:.2f}")
    
    if available_balance < MIN_TRADE_SIZE:
        message = (
            f"â›” *ØªØ­Ø°ÙŠØ±: Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ*\n"
            f"Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø­: ${available_balance:.2f}\n"
            f"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: ${MIN_TRADE_SIZE}"
        )
        send_telegram_message_via_api(message)
    
    print(f"âœ… Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø³ÙˆÙ‚ Ø¹Ø¨Ø± {len(SYMBOLS)} Ø¹Ù…Ù„Ø©...")
    
    while True:
        try:
            start_time = time.time()
            live_strategy_multi_timeframes()
            elapsed = time.time() - start_time
            sleep_time = max(300 - elapsed, 60)  # 5 Ø¯Ù‚Ø§Ø¦Ù‚ Ø¨ÙŠÙ† Ø§Ù„Ø¯ÙˆØ±Ø§Øª Ø£Ùˆ Ø¯Ù‚ÙŠÙ‚Ø© ÙƒØ­Ø¯ Ø£Ø¯Ù†Ù‰
            print(f"â±ï¸ Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¯ÙˆØ±Ø© ÙÙŠ {elapsed:.2f} Ø«Ø§Ù†ÙŠØ©")
            time.sleep(sleep_time)
        except KeyboardInterrupt:
            print("â›” ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬")
            break
        except Exception as e:
            print(f"Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: {str(e)}")
            time.sleep(60)
